---
title: "Example of regstudies workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Example of regstudies workflow}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Install and load necessary libraries for this example

```{r, warning=FALSE, message=FALSE}
library(regstudies) 
library(tidyverse)
library(vroom)
library(lubridate)
```



## Data preparation

For demonstration purpose we are going to create random cohort and registry datasets

```{r}
## Generate random cohort id data
cohort_data <- tibble::tibble(
  personid = seq(1201, 1500),
  gender = sample(c(1,2), 300, replace = T),
  postingdate = rep(as.Date("2000-01-01"), 300)
)

# Read ICD-codes so that we generate from all classes:
read_classes_tibble(regstudies:::charlson_classes) %>% 
  filter(!is.na(regex)) %>% 
  mutate(regex2=str_replace_all(regex,"^\\^","")) %>% 
  group_by(icd,class_charlson) %>%
  mutate(regex3=str_split(regex2,pattern="\\|\\^")) %>%
  mutate(regex4=purrr::map_chr(regex3,magrittr::extract(1))) %>% 
  pull(regex4) -> random_icd_codes

sample_at_least_once <- function(x, size, replace = FALSE, prob = NULL) {
  # size must be more than length(x)!
  if (size >= length(x)) {
    # take all elements at least once
    sample1<-sample(x=x,size=length(x),replace=FALSE,prob=prob)
    sample2<-sample(x=x,size=size-length(x),replace = replace,prob=prob)
    return(c(sample1,sample2))
  } else {
    return(NULL)
  }
}
#table(random_icd_codes)
#sample_at_least_once(unique(random_icd_codes), 17, replace = TRUE) %>%
#  table()

reg_data <- tibble::tibble(
  personid = sample(cohort_data$personid, 10000, replace = TRUE),
  CODE1 = sample_at_least_once(random_icd_codes, 10000, replace = TRUE),
  adm_date = sample(seq(as.Date("1990-01-01"), as.Date("2005-12-31"), by = 1), 10000, replace = T)
  # disc_date = ,
)
reg_data$disc_date <- (reg_data$adm_date + sample(seq(0,180), 10000, replace = T))
```


### Sample dataset 

Dataset `cohort_data` is base dataset including basic descriptive variables of the population (in this case only gener) and variable `posting_date` which is a survey letter posting date:

```{r}
summary(cohort_data)
```

Dataset `reg_data` is a dataset which has events for the selected population with ICD codes and date-variables:

```{r}
summary(reg_data)
```


Joining these two data sets we got data set ready for analyzes:

```{r}
# Join register data with population cohort data
d <- reg_data %>%
  left_join(cohort_data)

head(d)
```

We can also create a new help variable `icd` which determines if code is ICD-8, ICD-9 or ICD-10 by year:

```{r}
# Determine if codes are ICD-8, ICD-9 or ICD-10
d <- d %>%
  mutate(icd = case_when(
    year(disc_date) < 1987 ~ "icd8",
    year(disc_date) < 1996 & year(disc_date)>=1987 ~ "icd9",
    year(disc_date) >= 1996 ~ "icd10"
    ))
```

```{r}
# Check the number of different classes
d %>%
  select(CODE1) %>%
  table()

```

## Get first event per id

With tidyverse verbs you can slice first occurrence by

```{r}
d %>% 
  group_by(personid) %>% 
  arrange(adm_date) %>%
  dplyr::slice(1)
```

and with regstudies verbs you can do the same with

```{r}
d %>% 
  group_by(personid) %>%
  regstudies::get_first(var = adm_date)

```




## Filtering by date periods

Filter data set with occurrences of hospital visits. If person has been in hospital during the time period two years prior `postingdate` then those events are included.

```{r}
filtered_d <- d %>% 
  filter_date_interval(indexdate = postingdate,
                       time_before=years(2),
                       admission_date=adm_date,
                       discharge_date=disc_date)
head(filtered_d)
```

Filter dataset with either `adm_date` or `disc_date` within two years around `postingdate`

```{r}
filtered_d <- d %>% 
  regstudies::filter_date(indexdate=postingdate, 
                          range=years(2),
                          adm_date,
                          disc_date) 
head(filtered_d)
```


## Classifications

### Code classification by own csv table



```{r}
# Classify by Elixhauser:
my_classes <- read_classes_csv(file = "../data/elixhauser_classes.csv")

classified_d <- filtered_d %>%
  classify_codes(codes = CODE1,
                 diag_tbl = my_classes) 
head(classified_d)
```


### Elixhauser classification and scores

This calculates per row elixhauser classification. Check more info of classification from [classification tables](docs/articles/classification_tables.html)-section.

```{r}
elixscore <- filtered_d %>% 
  classify_elixhauser(icd_codes = CODE1)
head(elixscore)

# TODO: Scores
```

### Charlson classification and scores

```{r}
## Classifying Charlson comorbidity classes to long format

d %>% 
  classify_charlson(CODE1) -> charlson # ns. tidy standardi
head(charlson)
```

### Long data to wide data

```{r}
charlson %>%
  mutate(class_charlson=paste0("cl_",class_charlson)) %>% # TODO: laita tämä ominaisuus classify-funktioon sisälle!
  mutate(score_charlson=as.integer(score_charlson>0)) %>% 
  tidyr::pivot_wider(names_from="class_charlson",
                     values_from="score_charlson",
                     values_fill=0) %>%
  select(-all_of(c("cl_NA","label_charlson"))) -> wide
head(wide)
```

### Some extra: labeling wide data

```{r, eval=FALSE}
## calculating labels
regstudies:::charlson_classes %>%
  select(class_charlson,label_charlson) %>%
  mutate(class_charlson=paste0("cl_",class_charlson)) -> labels

# setting up the labels for wide data
for(i in 1:dim(labels)[1]) {
  l<-labels$class_charlson[i]
  if(!is.null(wide[[l]])) {
    attr(wide[[l]], "label") <- labels$label_charlson[i]
  }
}
head(wide)
```



Calculate Elixhauser scores by id's

```{r}
# Calculate scores
filtered_d %>% 
  classify_elixhauser(icd_codes = CODE1) %>% 
  sum_score(score_AHRQ, score_van_Walraven)
```





# TODO

## Elixhauser continues

```{r,eval=FALSE}
elixscore %>%
  get_var_types()

elixscore
elixscore <- left_join_replace_na(cohort %>% select(personid), elixscore)
#View(elixscore)

# [X] demoa Hospital Frailty Risk Score -indeksiä!
# [X] selvitä, mitkä funktiot on tarpeettomia ja mitkä tarpeellisia
# TODO: 
# - class, label ja score muotoon class_charlson, label_charlson ja score_charlson
#   -> classify_data_long -funktiossa!
# - korjaa classify_data_long -funktio sellaiseksi että se palauttaa koko datan!
# - tarvitaan left_join, joka tekee muuttujan tyypin mukaan käyttäjän haluaman täytön: esim. c("numeric"=0,"character"="Elixhauser")
#   -> tulee ehkä tarpeettomaksi, jos muutetaan class, label ja score uusille nimille

```



## Charlson classification

```{r, eval=FALSE}
# Charlson score:
#charlson_classes <- classes_to_wide(vroom(file = "data/classification_codes/charlson_classes_wide.csv"))
charlson_classes <- read_classes_csv(file = "data/classification_codes/charlson_classes_wide.csv")
#View(charlson_classes)

# dev:
dev1<-filtereddata %>%
  classify_data_long(icdcodes=CODE1,diag_tbl=charlson_classes)
dev2<-filtereddata %>%
  classify_long(icdcodes=CODE1,diag_tbl=charlson_classes)
dim(filtereddata)
dim(dev1)
dim(dev2)
# TODO: Jotain kummaa tässä on!

charlsonscore <- filtereddata %>%
  classify_data_long(icdcodes=CODE1,diag_tbl=charlson_classes) %>%
  rename(score_charlson=score) %>%
  sum_score(score_charlson)
charlsonscore <- left_join(cohort %>% select(personid), charlsonscore)
#View(charlsonscore)

# Hospital Frailty Risk Score:
hfrs_dat<-vroom(file = "data/classification_codes/hospital_frailty_risk_score_wide.csv")
hfrs_dat<-hfrs_dat %>%
  mutate(label="Frail group") %>%
  select(classification,class,label,score,icd10)
names(hfrs_dat)
write.table(hfrs_dat,file="data/classification_codes/hospital_frailty_risk_score_wide_v2.csv",sep=";",dec=".",row.names = FALSE)
View(hfrs_dat)
hfrs_classes <- read_classes_csv(file = "data/classification_codes/hospital_frailty_risk_score_wide_v2.csv")
#View(charlson_classes)
hfrsscore <- filtereddata %>%
  classify_data_long(icdcodes=CODE1,diag_tbl=hfrs_classes) %>%
  rename(score_charlson=score) %>%
  sum_score(score_charlson)

mode <- function(x) { # by Ken Williams at stackoverflow
  ux <- unique(x)
  ux <- ux[!is.na(ux)]
  ux[which.max(tabulate(match(x, ux)))]
}
mode(hfrsscore$classification)


hfrsscore <- left_join(cohort %>% select(personid), hfrsscore) %>%
  mutate(classification=mode(classification))
#  mutate(classification=ifelse(is.na(classification),mode(classification),classification))
View(hfrsscore)

dim(filtereddata %>% select(personid) %>% distinct())
dim(cohort)
dim(elixscore)
dim(charlsonscore)

bothscores<-left_join(elixscore %>% select(-classification),
                      charlsonscore %>% select(-classification),by="personid")
fill_na<-function(x,fill=0) ifelse(is.na(x),fill,x)
cohortscores<-left_join(cohort %>% select(personid),bothscores) %>%
  mutate_all(fill_na)
cohortscores %>%
  head(10)
cohortscores %>%
  filter(`sum(score_AHRQ)`+`sum(score_van_Walraven)`+`sum(score_charlson)`>0) %>%
  head(10)
plot(cohortscores)
cor(cohortscores)
```

